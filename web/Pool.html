<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>

<head>
<!-- steal these colour values from JavaDocs; meh -->
<style type = "text/css">
	a:link,  a:visited { color: #4a6782; }
	a:hover, a:focus   { color: #bb7a2a; }
	a:active           { color: #4A6782; }
	tr:nth-child(even) { background: #dee3e9; }
	div {
		margin:  4px 0;
		padding: 0 4px 4px 4px;
	}
	table      { width: 100%; }
	td         { padding: 4px; }
	h3, h1 {
		color: #2c4557;
		background-color: #dee3e9;
		padding:          4px;
	}
	h3 {
		margin:           0 -4px;
		padding:          4px;
	}
</style>
<title>Pool.h</title>
</head>


<body>

<h1>Pool.h</h1>

<ul>
	<li><a href = "#_declarations">Declarations</a></li>
	<li><a href = "#_summary">Function Summary</a></li>
	<li><a href = "#_detail">Function Detail</a></li>
</ul>

<p>
2016 Neil Edelman, distributed under the terms of the MIT License;
see readme.txt, or <a href = "https://opensource.org/licenses/MIT">https://opensource.org/licenses/MIT</a>.
</p>
<p>
<em>&lt;T&gt;Pool</em> is a dynamic array that stores unordered <em>&lt;T&gt;</em> in a memory pool,
which must be set using <em>POOL_TYPE</em>. You cannot shrink the capacity of this
data type, only cause it to grow. Resizing incurs amortised cost, done though
a Fibonacci sequence. <em>&lt;T&gt;Pool</em> is not synchronised. The preprocessor macros
are all undefined at the end of the file for convenience.
</p>
<dl>
	<dt>parameter: POOL_NAME, POOL_TYPE</dt>
	<dd>The name that literally becomes <em>&lt;T&gt;</em>, and a valid type associated therewith,
 accessible to the compiler at the time of inclusion; should be conformant to
 naming and to the maximum available length of identifiers. Must each be
 present before including.</dd>
	<dt>parameter: POOL_STACK</dt>
	<dd>Removing an element is normally done lazily through a linked-list internal to
 the pool. With this defined, there is no such linked-list; the data will be
 packed and one can only remove items by <a href = "#&lt;T&gt;PoolPop">&lt;T&gt;PoolPop</a>.</dd>
	<dt>parameter: POOL_MIGRATE_EACH</dt>
	<dd>Optional function implementing <em>&lt;PT&gt;Migrate</em>. Indices will remain the same
 throughout the lifetime of the data, but pointers may change on <em>realloc</em>
 expansion. This definition will call <em>POOL_MIGRATE_EACH</em> with all <em>&lt;T&gt;</em> in
 <em>&lt;T&gt;Pool</em>. Use when your data is self-referential, like a linked-list.</dd>
	<dt>parameter: POOL_MIGRATE_ALL</dt>
	<dd>Optional type <em>&lt;A&gt;</em>. When one may have pointers to the data that is contained
 in the <em>Pool</em> outside the data that can be accessed by the pool. It adds an
 element to the constructor, <em>&lt;PT&gt;MigrateAll migrate_all</em>, as well as it's
 constant parameter, <em>&lt;A&gt; all</em>. This usually is the parent of an agglomeration
 that includes and has references into the pool. This has the responsibility to
 call <a href = "#&lt;T&gt;MigratePointer">&lt;T&gt;MigratePointer</a> or some migrate function for all references.</dd>
	<dt>parameter: POOL_MIGRATE_UPDATE</dt>
	<dd>Optional type association with <em>&lt;S&gt;</em>. <em>&lt;S&gt;</em> should be a super-type of <em>&lt;T&gt;</em>.
 If not set, <em>&lt;S&gt;</em> is <em>&lt;T&gt;</em>. Used in <a href = "#&lt;T&gt;PoolUpdateNew">&lt;T&gt;PoolUpdateNew</a>.</dd>
	<dt>parameter: POOL_TO_STRING</dt>
	<dd>Optional print function implementing <em>&lt;T&gt;ToString</em>; makes available
 <a href = "#&lt;T&gt;PoolToString">&lt;T&gt;PoolToString</a>.</dd>
	<dt>parameter: POOL_TEST</dt>
	<dd>Unit testing framework using <em>&lt;T&gt;PoolTest</em>, included in a separate header,
 <em>../test/PoolTest.h</em>. Must be defined equal to a (random) filler function,
 satisfying <em>&lt;T&gt;Action</em>. If <em>NDEBUG</em> is not defined, turns on <em>assert</em> private
 function integrity testing. Requires <em>POOL_TO_STRING</em>.</dd>
	<dt>minimum standard</dt>
	<dd>C89</dd>
	<dt>author</dt>
	<dd>Neil</dd>
	<dt>version</dt>
	<dd>2018-04 Merged <em>Stack</em> into <em>Pool</em> again;
			augh ifdefs, but too much duplicate code.</dd>
	<dt>since</dt>
	<dd>2018-03 Why have an extra level of indirection?
			2018-02 Errno instead of custom errors.
			2017-12 Introduced <em>POOL_PARENT</em> for type-safety.
			2017-11 Forked <em>Stack</em> from <em>Pool</em>.
			2017-10 Replaced <em>PoolIsEmpty</em> by <em>PoolElement</em>, much more useful.
			2017-10 Renamed Pool; made migrate automatic.
			2017-07 Made migrate simpler.
			2017-05 Split <em>List</em> from <em>Pool</em>; much simpler.
			2017-01 Almost-redundant functions simplified.
			2016-11 Multi-index.
			2016-08 Permute.</dd>
</dl>


<a name = "_declarations"><!-- --></a><h2>Declarations</h2>

<div><a name = "struct Migrate"><!-- --></a>
<h3>struct Migrate</h3>
<pre><b>struct Migrate</b></pre>
<p>
Contains information about a <em>realloc</em>.
</p>
<dl>
</dl>
</div>

<div><a name = "typedef void (*&lt;PT&gt;Migrate)(T *const data,
	const struct Migrate *const migrate)"><!-- --></a>
<h3>typedef void (*&lt;PT&gt;Migrate)(T *const data,
	const struct Migrate *const migrate)</h3>
<pre><b>typedef void (*&lt;PT&gt;Migrate)(T *const data,
	const struct Migrate *const migrate)</b></pre>
<p>
This is the migrate function for <em>&lt;T&gt;</em>.
</p>
<dl>
</dl>
</div>

<div><a name = "typedef void (*&lt;PT&gt;MigrateAll)(A *const all,
	const struct Migrate *const migrate)"><!-- --></a>
<h3>typedef void (*&lt;PT&gt;MigrateAll)(A *const all,
	const struct Migrate *const migrate)</h3>
<pre><b>typedef void (*&lt;PT&gt;MigrateAll)(A *const all,
	const struct Migrate *const migrate)</b></pre>
<p>
Function call on <em>realloc</em> if <em>POOL_MIGRATE_ALL</em> is defined.
</p>
<dl>
</dl>
</div>

<div><a name = "typedef void (*&lt;PT&gt;ToString)(const T *, char (*const)[12])"><!-- --></a>
<h3>typedef void (*&lt;PT&gt;ToString)(const T *, char (*const)[12])</h3>
<pre><b>typedef void (*&lt;PT&gt;ToString)(const T *, char (*const)[12])</b></pre>
<p>
Responsible for turning <em>&lt;T&gt;</em> (the first argument) into a 12 <em>char</em>
null-terminated output string (the second.) Used for <em>POOL_TO_STRING</em>.
</p>
<dl>
</dl>
</div>

<div><a name = "struct &lt;T&gt;Pool"><!-- --></a>
<h3>struct &lt;T&gt;Pool</h3>
<pre><b>struct &lt;T&gt;Pool</b></pre>
<p>
The pool. To instantiate, see <a href = "#&lt;T&gt;Pool">&lt;T&gt;Pool</a>.
</p>
<dl>
</dl>
</div>


<a name = "_summary"><!-- --></a><h2>Function Summary</h2>

<table>
<tr><th>Return Type</th><th>Function Name</th><th>Argument List</th></tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;Pool_">&lt;T&gt;Pool_</a></td>
	<td>struct &lt;T&gt;Pool *const pool</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;Pool">&lt;T&gt;Pool</a></td>
	<td>struct &lt;T&gt;Pool *const pool,
	const &lt;PT&gt;MigrateAll migrate_all, A *const all</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;Pool">&lt;T&gt;Pool</a></td>
	<td>struct &lt;T&gt;Pool *const pool</td>
</tr>
<tr>
	<td>static size_t</td>
	<td><a href = "#&lt;T&gt;PoolSize">&lt;T&gt;PoolSize</a></td>
	<td>const struct &lt;T&gt;Pool *const pool</td>
</tr>
<tr>
	<td>static int</td>
	<td><a href = "#&lt;T&gt;PoolRemove">&lt;T&gt;PoolRemove</a></td>
	<td>struct &lt;T&gt;Pool *const pool, T *const data</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;PoolClear">&lt;T&gt;PoolClear</a></td>
	<td>struct &lt;T&gt;Pool *const pool</td>
</tr>
<tr>
	<td>static T *</td>
	<td><a href = "#&lt;T&gt;PoolGet">&lt;T&gt;PoolGet</a></td>
	<td>const struct &lt;T&gt;Pool *const pool, const size_t idx</td>
</tr>
<tr>
	<td>static size_t</td>
	<td><a href = "#&lt;T&gt;PoolIndex">&lt;T&gt;PoolIndex</a></td>
	<td>struct &lt;T&gt;Pool *const pool, T *const data</td>
</tr>
<tr>
	<td>static T *</td>
	<td><a href = "#&lt;T&gt;PoolPeek">&lt;T&gt;PoolPeek</a></td>
	<td>const struct &lt;T&gt;Pool *const pool</td>
</tr>
<tr>
	<td>static T *</td>
	<td><a href = "#&lt;T&gt;PoolPop">&lt;T&gt;PoolPop</a></td>
	<td>struct &lt;T&gt;Pool *const pool</td>
</tr>
<tr>
	<td>static T *</td>
	<td><a href = "#&lt;T&gt;PoolNext">&lt;T&gt;PoolNext</a></td>
	<td>struct &lt;T&gt;Pool *const pool, T *const prev</td>
</tr>
<tr>
	<td>static T *</td>
	<td><a href = "#&lt;T&gt;PoolNew">&lt;T&gt;PoolNew</a></td>
	<td>struct &lt;T&gt;Pool *const pool</td>
</tr>
<tr>
	<td>static T *</td>
	<td><a href = "#&lt;T&gt;PoolUpdateNew">&lt;T&gt;PoolUpdateNew</a></td>
	<td>struct &lt;T&gt;Pool *const pool, S **const update_ptr</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;PoolForEach">&lt;T&gt;PoolForEach</a></td>
	<td>struct &lt;T&gt;Pool *const pool,
	const &lt;PT&gt;Action action</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;PoolMigrateEach">&lt;T&gt;PoolMigrateEach</a></td>
	<td>struct &lt;T&gt;Pool *const pool,
	const &lt;PT&gt;Migrate handler, const struct Migrate *const migrate</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;PoolMigratePointer">&lt;T&gt;PoolMigratePointer</a></td>
	<td>T **const data_ptr,
	const struct Migrate *const migrate</td>
</tr>
<tr>
	<td>static const char *</td>
	<td><a href = "#&lt;T&gt;PoolToString">&lt;T&gt;PoolToString</a></td>
	<td>const struct &lt;T&gt;Pool *const pool</td>
</tr>
</table>


<a name = "_detail"><!-- --></a><h2>Function Detail</h2>

<div><a name = "&lt;T&gt;Pool_"><!-- --></a>
<h3>&lt;T&gt;Pool_</h3>
<pre>static void <b>&lt;T&gt;Pool_</b> (struct &lt;T&gt;Pool *const pool)</pre>
<p>
Destructor for <em>pool</em>. All the <em>pool</em> contents should not be accessed
anymore and the <em>pool</em> takes no memory.
</p>
<dl>
	<dt>parameter: pool</dt>
	<dd>If null, does nothing.</dd>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;Pool"><!-- --></a>
<h3>&lt;T&gt;Pool</h3>
<pre>static void <b>&lt;T&gt;Pool</b> (struct &lt;T&gt;Pool *const pool,
	const &lt;PT&gt;MigrateAll migrate_all, A *const all)</pre>
<p>
Initialises <em>pool</em> to be empty and have a migrate function with a
parameter. This is the constructor if <em>POOL_MIGRATE_ALL</em> is specified.
</p>
<dl>
	<dt>parameter: pool</dt>
	<dd>If null, does nothing.</dd>
	<dt>parameter: migrate_all</dt>
	<dd>The general <em>&lt;PT&gt;MigrateAll</em> function.</dd>
	<dt>parameter: all</dt>
	<dd>The general migrate parameter.</dd>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;Pool"><!-- --></a>
<h3>&lt;T&gt;Pool</h3>
<pre>static void <b>&lt;T&gt;Pool</b> (struct &lt;T&gt;Pool *const pool)</pre>
<p>
Initialises <em>pool</em> to be empty. This is the constructor is
<em>POOL_MIGRATE_ALL</em> is not specified. If it is <em>static</em> data then it is
initialised by default and one doesn't have to call this.
</p>
<dl>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolSize"><!-- --></a>
<h3>&lt;T&gt;PoolSize</h3>
<pre>static size_t <b>&lt;T&gt;PoolSize</b> (const struct &lt;T&gt;Pool *const pool)</pre>
<p>
If <em>POOL_STACK</em> is specified, otherwise it doesn't keep track of the size.
</p>
<dl>
	<dt>parameter: pool</dt>
	<dd>If null, returns zero.</dd>
	<dt>return</dt>
	<dd>The current size of the stack.</dd>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolRemove"><!-- --></a>
<h3>&lt;T&gt;PoolRemove</h3>
<pre>static int <b>&lt;T&gt;PoolRemove</b> (struct &lt;T&gt;Pool *const pool, T *const data)</pre>
<p>
Removes <em>data</em> from <em>pool</em>. Only present if <em>POOL_STACK</em> is not defined.
</p>
<dl>
	<dt>parameter: pool, data</dt>
	<dd>If null, returns false.</dd>
	<dt>return</dt>
	<dd>Success, otherwise <em>errno</em> will be set for valid input.</dd>
	<dt>throws: EDOM</dt>
	<dd><em>data</em> is not part of <em>pool</em>.</dd>
	<dt>order</dt>
	<dd>amortised O(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolClear"><!-- --></a>
<h3>&lt;T&gt;PoolClear</h3>
<pre>static void <b>&lt;T&gt;PoolClear</b> (struct &lt;T&gt;Pool *const pool)</pre>
<p>
Removes all from <em>pool</em>, but leaves the <em>pool</em> memory alone; if one wants
to remove memory, see <a href = "#Pool_">Pool_</a>.
</p>
<dl>
	<dt>parameter: pool</dt>
	<dd>If null, does nothing.</dd>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolGet"><!-- --></a>
<h3>&lt;T&gt;PoolGet</h3>
<pre>static T * <b>&lt;T&gt;PoolGet</b> (const struct &lt;T&gt;Pool *const pool, const size_t idx)</pre>
<p>
Gets an existing element by index. Causing something to be added to the
<em>&lt;T&gt;Pool</em> may invalidate this pointer.
</p>
<dl>
	<dt>parameter: pool</dt>
	<dd>If null, returns null.</dd>
	<dt>parameter: idx</dt>
	<dd>Index.</dd>
	<dt>return</dt>
	<dd>If failed, returns a null pointer.</dd>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolIndex"><!-- --></a>
<h3>&lt;T&gt;PoolIndex</h3>
<pre>static size_t <b>&lt;T&gt;PoolIndex</b> (struct &lt;T&gt;Pool *const pool, T *const data)</pre>
<p>
Gets an index given <em>data</em>.
</p>
<dl>
	<dt>parameter: data</dt>
	<dd>If the element is not part of the <em>Pool</em>, behaviour is undefined.</dd>
	<dt>return</dt>
	<dd>An index.</dd>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
	<dt>fixme</dt>
	<dd>Untested.</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolPeek"><!-- --></a>
<h3>&lt;T&gt;PoolPeek</h3>
<pre>static T * <b>&lt;T&gt;PoolPeek</b> (const struct &lt;T&gt;Pool *const pool)</pre>
<dl>
	<dt>parameter: pool</dt>
	<dd>If null, returns null.</dd>
	<dt>return</dt>
	<dd>One element from the pool or null if the pool is empty. If
 <em>POOL_STACK</em> was specified, this will be the last element added, otherwise, it
 may not be, but it is deterministic. Causing something to be added to the
 <em>pool</em> may invalidate this pointer.</dd>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
	<dt>fixme</dt>
	<dd>Untested.</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolPop"><!-- --></a>
<h3>&lt;T&gt;PoolPop</h3>
<pre>static T * <b>&lt;T&gt;PoolPop</b> (struct &lt;T&gt;Pool *const pool)</pre>
<p>
The same value as <a href = "#&lt;T&gt;PoolPeek">&lt;T&gt;PoolPeek</a>.
</p>
<dl>
	<dt>parameter: pool</dt>
	<dd>If null, returns null.</dd>
	<dt>return</dt>
	<dd>Value from the the top of the <em>pool</em> that is removed or null if the
 stack is empty. Causing something to be added to the <em>pool</em> may invalidate
 this pointer.</dd>
	<dt>order</dt>
	<dd>&Theta;(1) (amortized if not <em>POOL_STACK</em>)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolNext"><!-- --></a>
<h3>&lt;T&gt;PoolNext</h3>
<pre>static T * <b>&lt;T&gt;PoolNext</b> (struct &lt;T&gt;Pool *const pool, T *const prev)</pre>
<p>
Provides a way to iterate through the <em>pool</em>. If <em>&lt;T&gt; = &lt;S&gt;</em>, it is safe to
add using <em>PoolUpdateNew</em> with the return value as <em>update</em>. If <em>POOL_STACK</em>
is not defined, it is safe to remove an element,
</p>
<dl>
	<dt>parameter: pool</dt>
	<dd>If null, returns null. If <em>prev</em> is not from this <em>pool</em> and not
 null, returns null.</dd>
	<dt>parameter: prev</dt>
	<dd>Set it to null to start the iteration.</dd>
	<dt>return</dt>
	<dd>A pointer to the next element or null if there are no more.</dd>
	<dt>order</dt>
	<dd>&Theta;(1) (or O(pool space that has been deleted) if not <em>POOL_STACK</em>)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolNew"><!-- --></a>
<h3>&lt;T&gt;PoolNew</h3>
<pre>static T * <b>&lt;T&gt;PoolNew</b> (struct &lt;T&gt;Pool *const pool)</pre>
<p>
Gets an uninitialised new element. May move the <em>Pool</em> to a new memory
location to fit the new size.
</p>
<dl>
	<dt>parameter: pool</dt>
	<dd>If is null, returns null.</dd>
	<dt>return</dt>
	<dd>A new, un-initialised, element, or null and <em>errno</em> may be set.</dd>
	<dt>throws: ERANGE</dt>
	<dd>Tried allocating more then can fit in <em>size_t</em> objects.</dd>
	<dt>throws: <em>realloc</em> errors</dt>
	<dd><em>IEEE Std 1003.1-2001</em>.</dd>
	<dt>order</dt>
	<dd>amortised O(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolUpdateNew"><!-- --></a>
<h3>&lt;T&gt;PoolUpdateNew</h3>
<pre>static T * <b>&lt;T&gt;PoolUpdateNew</b> (struct &lt;T&gt;Pool *const pool, S **const update_ptr)</pre>
<p>
Gets an uninitialised new element and updates the <em>update_ptr</em> if it is
within the memory region that was changed. For example, when iterating a
pointer and new element is needed that could change the pointer.
</p>
<dl>
	<dt>parameter: pool</dt>
	<dd>If null, returns null.</dd>
	<dt>parameter: update_ptr</dt>
	<dd>Pointer to update on memory move.</dd>
	<dt>return</dt>
	<dd>A new, un-initialised, element, or null and <em>errno</em> may be set.</dd>
	<dt>throws: ERANGE</dt>
	<dd>Tried allocating more then can fit in <em>size_t</em>.</dd>
	<dt>throws: <em>realloc</em> errors</dt>
	<dd><em>IEEE Std 1003.1-2001</em>.</dd>
	<dt>order</dt>
	<dd>amortised O(1)</dd>
	<dt>fixme</dt>
	<dd>Untested.</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolForEach"><!-- --></a>
<h3>&lt;T&gt;PoolForEach</h3>
<pre>static void <b>&lt;T&gt;PoolForEach</b> (struct &lt;T&gt;Pool *const pool,
	const &lt;PT&gt;Action action)</pre>
<p>
Iterates though <em>pool</em> from the bottom and calls <em>action</em> on all the
elements. The topology of the list can not change while in this function.
</p>
<dl>
	<dt>parameter: stack, action</dt>
	<dd>If null, does nothing.</dd>
	<dt>order</dt>
	<dd>O(<em>size</em> &times; <em>action</em>)</dd>
	<dt>fixme</dt>
	<dd>Untested.</dd>
	<dt>fixme</dt>
	<dd>Sequence interface.</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolMigrateEach"><!-- --></a>
<h3>&lt;T&gt;PoolMigrateEach</h3>
<pre>static void <b>&lt;T&gt;PoolMigrateEach</b> (struct &lt;T&gt;Pool *const pool,
	const &lt;PT&gt;Migrate handler, const struct Migrate *const migrate)</pre>
<p>
Use when the pool has pointers to another memory move structure in the
<em>MigrateAll</em> function of the other data type.
</p>
<dl>
	<dt>parameter: pool</dt>
	<dd>If null, does nothing.</dd>
	<dt>parameter: handler</dt>
	<dd>If null, does nothing, otherwise has the responsibility of
 calling the other data type's migrate pointer function on all pointers
 affected by the <em>realloc</em>.</dd>
	<dt>parameter: migrate</dt>
	<dd>If null, does nothing. Should only be called in a <em>Migrate</em>
 function; pass the <em>migrate</em> parameter.</dd>
	<dt>order</dt>
	<dd>O(<em>greatest size</em>)</dd>
	<dt>fixme</dt>
	<dd>Untested.</dd>
	<dt>fixme</dt>
	<dd>Migrate interface.</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolMigratePointer"><!-- --></a>
<h3>&lt;T&gt;PoolMigratePointer</h3>
<pre>static void <b>&lt;T&gt;PoolMigratePointer</b> (T **const data_ptr,
	const struct Migrate *const migrate)</pre>
<p>
Passed a <em>migrate</em> parameter, allows pointers to the pool to be updated. It
doesn't affect pointers not in the <em>realloc</em>ed region.
</p>
<dl>
	<dt>order</dt>
	<dd>&Omega;(1)</dd>
	<dt>fixme</dt>
	<dd>Untested.</dd>
	<dt>fixme</dt>
	<dd>Migrate interface.</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolToString"><!-- --></a>
<h3>&lt;T&gt;PoolToString</h3>
<pre>static const char * <b>&lt;T&gt;PoolToString</b> (const struct &lt;T&gt;Pool *const pool)</pre>
<p>
Can print 4 things at once before it overwrites. One must pool
<em>POOL_TO_STRING</em> to a function implementing <em>&lt;T&gt;ToString</em> to get this
functionality.
</p>
<dl>
	<dt>return</dt>
	<dd>Prints <em>pool</em> in a static buffer.</dd>
	<dt>order</dt>
	<dd>&Theta;(1); it has a 255 character limit; every element takes some of it.</dd>
	<dt>fixme</dt>
	<dd>ToString interface.</dd>
</dl>
</div>


</body>
</html>

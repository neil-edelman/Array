<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>

<head>
<!-- steal these colour values from JavaDocs; meh -->
<style type = "text/css">
	a:link,  a:visited { color: #4a6782; }
	a:hover, a:focus   { color: #bb7a2a; }
	a:active           { color: #4A6782; }
	tr:nth-child(even) { background: #dee3e9; }
	div {
		margin:  4px 0;
		padding: 0 4px 4px 4px;
	}
	table      { width: 100%; }
	td         { padding: 4px; }
	h3, h1 {
		color: #2c4557;
		background-color: #dee3e9;
		padding:          4px;
	}
	h3 {
		margin:           0 -4px;
		padding:          4px;
	}
</style>
<title>Pool.h</title>
</head>


<body>

<h1>Pool.h</h1>

<ul>
	<li><a href = "#_declarations">Declarations</a></li>
	<li><a href = "#_summary">Function Summary</a></li>
	<li><a href = "#_detail">Function Detail</a></li>
</ul>

<p>
2016 Neil Edelman, distributed under the terms of the MIT License;
see readme.txt, or <a href = "https://opensource.org/licenses/MIT">https://opensource.org/licenses/MIT</a>.
</p>
<p>
<em>&lt;T&gt;Pool</em> is a dynamic array that stores unordered <em>&lt;T&gt;</em>, which must be set
using <em>POOL_TYPE</em>. Removing an element is done lazily through a linked-list
internal to the pool; as such, indices will remain the same throughout the
lifetime of the data. You cannot shrink the size of this data type, only cause
it to grow. Resizing incurs amortised cost, done though a Fibonacci sequence.
<em>&lt;T&gt;Pool</em> is not synchronised. The preprocessor macros are all undefined at
the end of the file for convenience when including multiple pool types in the
same file.
</p>
<dl>
	<dt>parameter: POOL_NAME</dt>
	<dd>This literally becomes <em>&lt;T&gt;</em>. As it's used in function names, this should
 comply with naming rules and be unique; required.</dd>
	<dt>parameter: POOL_TYPE</dt>
	<dd>The type associated with <em>&lt;T&gt;</em>. Has to be a valid type, accessible to the
 compiler at the time of inclusion; required.</dd>
	<dt>parameter: POOL_TO_STRING</dt>
	<dd>Optional print function implementing <em>&lt;T&gt;ToString</em>; makes available
 <a href = "#&lt;T&gt;PoolToString">&lt;T&gt;PoolToString</a>.</dd>
	<dt>parameter: POOL_DEBUG</dt>
	<dd>Prints information to <em>stderr</em>. Requires <em>POOL_TO_STRING</em>.</dd>
	<dt>parameter: POOL_TEST</dt>
	<dd>Unit testing framework using <em>&lt;T&gt;PoolTest</em>, included in a separate header,
 <em>../test/PoolTest.h</em>. Must be defined equal to a (random) filler function,
 satisfying <em>&lt;T&gt;Action</em>. If <em>NDEBUG</em> is not defined, turns on <em>assert</em> private
 function integrity testing. Requires <em>POOL_TO_STRING</em>.</dd>
	<dt>minimum standard</dt>
	<dd>C89/90</dd>
	<dt>author</dt>
	<dd>Neil</dd>
	<dt>version</dt>
	<dd>2017-10 Replaced <em>PoolIsEmpty</em> by <em>PoolElement</em>, much more useful.</dd>
	<dt>since</dt>
	<dd>2017-10 Renamed Pool; made migrate automatic.
			2017-07 Made migrate simpler.
			2017-05 Split <em>List</em> from <em>Pool</em>; much simpler.
			2017-01 Almost-redundant functions simplified.
			2016-11 Multi-index.
			2016-08 Permute.</dd>
</dl>


<a name = "_declarations"><!-- --></a><h2>Declarations</h2>

<div><a name = "typedef void (*&lt;T&gt;Action)(T *const element)"><!-- --></a>
<h3>typedef void (*&lt;T&gt;Action)(T *const element)</h3>
<pre><b>typedef void (*&lt;T&gt;Action)(T *const element)</b></pre>
<p>
Operates by side-effects only. Used for <em>POOL_TEST</em>.
</p>
<dl>
</dl>
</div>

<div><a name = "typedef void (*&lt;T&gt;ToString)(const T *, char (*const)[12])"><!-- --></a>
<h3>typedef void (*&lt;T&gt;ToString)(const T *, char (*const)[12])</h3>
<pre><b>typedef void (*&lt;T&gt;ToString)(const T *, char (*const)[12])</b></pre>
<p>
Responsible for turning <em>&lt;T&gt;</em> (the first argument) into a 12 <em>char</em>
null-terminated output string (the second.) Used for <em>POOL_TO_STRING</em>.
</p>
<dl>
</dl>
</div>

<div><a name = "struct Migrate"><!-- --></a>
<h3>struct Migrate</h3>
<pre><b>struct Migrate</b></pre>
<p>
Contains information about a <em>realloc</em>.
</p>
<dl>
</dl>
</div>

<div><a name = "typedef void (*Migrate)(void *const parent,
	const struct Migrate *const migrate)"><!-- --></a>
<h3>typedef void (*Migrate)(void *const parent,
	const struct Migrate *const migrate)</h3>
<pre><b>typedef void (*Migrate)(void *const parent,
	const struct Migrate *const migrate)</b></pre>
<p>
Function call on <em>realloc</em>.
</p>
<dl>
</dl>
</div>

<div><a name = "struct &lt;T&gt;Pool"><!-- --></a>
<h3>struct &lt;T&gt;Pool</h3>
<pre><b>struct &lt;T&gt;Pool</b></pre>
<p>
The pool. To instantiate, see <a href = "#&lt;T&gt;Pool">&lt;T&gt;Pool</a>.
</p>
<dl>
</dl>
</div>


<a name = "_summary"><!-- --></a><h2>Function Summary</h2>

<table>
<tr><th>Return Type</th><th>Function Name</th><th>Argument List</th></tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;Pool_">&lt;T&gt;Pool_</a></td>
	<td>struct &lt;T&gt;Pool **const thisp</td>
</tr>
<tr>
	<td>static struct &lt;T&gt;Pool *</td>
	<td><a href = "#&lt;T&gt;Pool">&lt;T&gt;Pool</a></td>
	<td>const Migrate migrate, void *const parent</td>
</tr>
<tr>
	<td>static const char *</td>
	<td><a href = "#&lt;T&gt;PoolGetError">&lt;T&gt;PoolGetError</a></td>
	<td>struct &lt;T&gt;Pool *const this</td>
</tr>
<tr>
	<td>static T *</td>
	<td><a href = "#&lt;T&gt;PoolElement">&lt;T&gt;PoolElement</a></td>
	<td>const struct &lt;T&gt;Pool *const this</td>
</tr>
<tr>
	<td>static int</td>
	<td><a href = "#&lt;T&gt;PoolIsElement">&lt;T&gt;PoolIsElement</a></td>
	<td>struct &lt;T&gt;Pool *const this, const size_t idx</td>
</tr>
<tr>
	<td>static T *</td>
	<td><a href = "#&lt;T&gt;PoolGetElement">&lt;T&gt;PoolGetElement</a></td>
	<td>struct &lt;T&gt;Pool *const this, const size_t idx</td>
</tr>
<tr>
	<td>static size_t</td>
	<td><a href = "#&lt;T&gt;PoolGetIndex">&lt;T&gt;PoolGetIndex</a></td>
	<td>struct &lt;T&gt;Pool *const this,
	const T *const element</td>
</tr>
<tr>
	<td>static int</td>
	<td><a href = "#&lt;T&gt;PoolReserve">&lt;T&gt;PoolReserve</a></td>
	<td>struct &lt;T&gt;Pool *const this,
	const size_t min_capacity</td>
</tr>
<tr>
	<td>static T *</td>
	<td><a href = "#&lt;T&gt;PoolNew">&lt;T&gt;PoolNew</a></td>
	<td>struct &lt;T&gt;Pool *const this</td>
</tr>
<tr>
	<td>static int</td>
	<td><a href = "#&lt;T&gt;PoolRemove">&lt;T&gt;PoolRemove</a></td>
	<td>struct &lt;T&gt;Pool *const this, T *const data</td>
</tr>
<tr>
	<td>static void</td>
	<td><a href = "#&lt;T&gt;PoolClear">&lt;T&gt;PoolClear</a></td>
	<td>struct &lt;T&gt;Pool *const this</td>
</tr>
<tr>
	<td>static const char *</td>
	<td><a href = "#&lt;T&gt;PoolToString">&lt;T&gt;PoolToString</a></td>
	<td>const struct &lt;T&gt;Pool *const this</td>
</tr>
</table>


<a name = "_detail"><!-- --></a><h2>Function Detail</h2>

<div><a name = "&lt;T&gt;Pool_"><!-- --></a>
<h3>&lt;T&gt;Pool_</h3>
<pre>static void <b>&lt;T&gt;Pool_</b> (struct &lt;T&gt;Pool **const thisp)</pre>
<p>
Destructor for Pool. Make sure that the pool's contents will not be
accessed anymore.
</p>
<dl>
	<dt>parameter: thisp</dt>
	<dd>A reference to the object that is to be deleted; it will be pool
 to null. If it is already null or it points to null, doesn't do anything.</dd>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;Pool"><!-- --></a>
<h3>&lt;T&gt;Pool</h3>
<pre>static struct &lt;T&gt;Pool * <b>&lt;T&gt;Pool</b> (const Migrate migrate, void *const parent)</pre>
<p>
Constructs an empty <em>Pool</em> with capacity Fibonacci6, which is 8.
</p>
<dl>
	<dt>parameter: migrate</dt>
	<dd>The ADT parent's <em>Migrate</em> function; required.</dd>
	<dt>parameter: parent</dt>
	<dd>The parent itself; to have multiple parents, implement an
 intermediary <em>Migrate</em> function that takes multiple values; required.</dd>
	<dt>return</dt>
	<dd>A new <em>Pool</em> for the polymorphic variable <em>parent</em>.</dd>
	<dt>throws: POOL_PARAMETER, POOL_ERRNO</dt>
	<dd>Use <em>PoolError(0)</em> to get the error.</dd>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolGetError"><!-- --></a>
<h3>&lt;T&gt;PoolGetError</h3>
<pre>static const char * <b>&lt;T&gt;PoolGetError</b> (struct &lt;T&gt;Pool *const this)</pre>
<p>
See what's the error if something goes wrong. Resets the error.
</p>
<dl>
	<dt>return</dt>
	<dd>The last error string.</dd>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolElement"><!-- --></a>
<h3>&lt;T&gt;PoolElement</h3>
<pre>static T * <b>&lt;T&gt;PoolElement</b> (const struct &lt;T&gt;Pool *const this)</pre>
<dl>
	<dt>return</dt>
	<dd>One value from the pool or null if the pool is empty. It selects
 the position in the memory which is farthest from the start of the buffer
 deterministically. Generally, you can't select which element you want, but if
 the pool has been treated like a stack, this is peek.</dd>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
	<dt>fixme</dt>
	<dd>Untested.</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolIsElement"><!-- --></a>
<h3>&lt;T&gt;PoolIsElement</h3>
<pre>static int <b>&lt;T&gt;PoolIsElement</b> (struct &lt;T&gt;Pool *const this, const size_t idx)</pre>
<p>
Is <em>idx</em> a valid index for <em>this</em>.
</p>
<dl>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolGetElement"><!-- --></a>
<h3>&lt;T&gt;PoolGetElement</h3>
<pre>static T * <b>&lt;T&gt;PoolGetElement</b> (struct &lt;T&gt;Pool *const this, const size_t idx)</pre>
<p>
Gets an existing element by index. Causing something to be added to the
<em>Pool</em> may invalidate this pointer.
</p>
<dl>
	<dt>parameter: this</dt>
	<dd>If <em>this</em> is null, returns null.</dd>
	<dt>parameter: idx</dt>
	<dd>Index.</dd>
	<dt>return</dt>
	<dd>If failed, returns a null pointer and the error condition will be set.</dd>
	<dt>throws</dt>
	<dd>POOL_OUT_OF_BOUNDS</dd>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolGetIndex"><!-- --></a>
<h3>&lt;T&gt;PoolGetIndex</h3>
<pre>static size_t <b>&lt;T&gt;PoolGetIndex</b> (struct &lt;T&gt;Pool *const this,
	const T *const element)</pre>
<p>
Gets an index given an element. If the element is not part of the <em>Pool</em>,
behaviour is undefined.
</p>
<dl>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
	<dt>fixme</dt>
	<dd>Untested.</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolReserve"><!-- --></a>
<h3>&lt;T&gt;PoolReserve</h3>
<pre>static int <b>&lt;T&gt;PoolReserve</b> (struct &lt;T&gt;Pool *const this,
	const size_t min_capacity)</pre>
<p>
Increases the capacity of this Pool to ensure that it can hold at least
the number of elements specified by the <em>min_capacity</em>.
</p>
<dl>
	<dt>parameter: this</dt>
	<dd>If <em>this</em> is null, returns false.</dd>
	<dt>return</dt>
	<dd>True if the capacity increase was viable; otherwise the pool is not
 touched and the error condition is pool.</dd>
	<dt>throws</dt>
	<dd>POOL_ERRNO, POOL_OVERFLOW</dd>
	<dt>order</dt>
	<dd>&Omega;(1), O(<em>capacity</em>)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolNew"><!-- --></a>
<h3>&lt;T&gt;PoolNew</h3>
<pre>static T * <b>&lt;T&gt;PoolNew</b> (struct &lt;T&gt;Pool *const this)</pre>
<p>
Gets an uninitialised new element.
</p>
<dl>
	<dt>parameter: this</dt>
	<dd>If <em>this</em> is null, returns null.</dd>
	<dt>return</dt>
	<dd>If failed, returns a null pointer and the error condition will be set.</dd>
	<dt>throws</dt>
	<dd>POOL_OVERFLOW, POOL_ERRNO</dd>
	<dt>order</dt>
	<dd>amortised O(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolRemove"><!-- --></a>
<h3>&lt;T&gt;PoolRemove</h3>
<pre>static int <b>&lt;T&gt;PoolRemove</b> (struct &lt;T&gt;Pool *const this, T *const data)</pre>
<p>
Removes an element associated with <em>data</em> from <em>this</em>.
</p>
<dl>
	<dt>parameter: this</dt>
	<dd>If <em>this</em> is null, returns false.</dd>
	<dt>return</dt>
	<dd>Success.</dd>
	<dt>throws</dt>
	<dd>POOL_OUT_OF_BOUNDS</dd>
	<dt>order</dt>
	<dd>amortised O(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolClear"><!-- --></a>
<h3>&lt;T&gt;PoolClear</h3>
<pre>static void <b>&lt;T&gt;PoolClear</b> (struct &lt;T&gt;Pool *const this)</pre>
<p>
Removes all data from <em>this</em>.
</p>
<dl>
	<dt>order</dt>
	<dd>&Theta;(1)</dd>
</dl>
</div>

<div><a name = "&lt;T&gt;PoolToString"><!-- --></a>
<h3>&lt;T&gt;PoolToString</h3>
<pre>static const char * <b>&lt;T&gt;PoolToString</b> (const struct &lt;T&gt;Pool *const this)</pre>
<p>
Can print 4 things at once before it overwrites. One must pool
<em>POOL_TO_STRING</em> to a function implementing <em>&lt;T&gt;ToString</em> to get this
functionality.
</p>
<dl>
	<dt>return</dt>
	<dd>Prints <em>this</em> in a static buffer.</dd>
	<dt>order</dt>
	<dd>&Theta;(1); it has a 255 character limit; every element takes some of it.</dd>
</dl>
</div>


</body>
</html>
